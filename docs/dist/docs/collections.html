<!DOCTYPE html><html lang="en"><head>
<meta charset="UTF-8">
<meta name="viewport"content="width=device-width, initial-scale=1">
<title> | Website Title</title>
<meta name="description"content="Website Description"/>
<meta property="og:title"content=""/>
<meta property="og:description"content=""/>
<meta property="og:image"content="localhost:6969/"/>
<meta property="og:image:alt"content=""/>
<meta property="og:locale"content="en_US"/>
<meta property="og:type"content="website"/>
<meta property="og:url"content="localhost:6969/"/>
<meta name="twitter:card"content=""/>
<meta name="color-scheme" content="light dark" />
<link rel="canonical"href="">
<link rel="icon"href="../images/favicons/favicon.ico">
<!-- <link rel="icon"href="images/favicons/favicon.svg"type="image/svg+xml"> -->
<link rel="apple-touch-icon"href="../images/favicons/apple-touch-icon.png">
<link rel="manifest"href="../images/favicons/site.webmanifest">
<link rel="stylesheet" href="../css/pico.min.css" />
<style>.bs-nav-1 {
                border-bottom-color: grey;
                border-bottom-style: solid;
                border-bottom-width: 1px;
                padding: 0rem 2rem 0rem 2rem;
            }</style></head><body><br><br><h1>Collections
</h1><p>All Collections are reference types in Beanstalk, which means they are references to underlying data. They work a little bit like tables in Lua.
</p><br><p>Single expression or value wrapped in parenthesis is just evaluated as the expression or value itself and does not automatically become a collection.
</p><br><h2>Literals
</h2><p>By simply wrapping a list of values in parethesis and not specifying a type, you create a tuple literal.
</p><br><span>(1, 2, 3)
</span><br><br><h2>Fixed Collections
</h2><p>Tuples are a fixed size and can contain any type. Tuples have implicit behaviours that allow for easy unpacking, comparison and assignment.
</p><br><p>If a tuple only contains one value in parenthesis, it becomes equaivalent to a single value rather than a collection of values.
</p><br><p>Tuples can also contain named values that can be accessed by name rather than index. This is done by providing a variable name just before the value.
</p><br><p>When creating a tuple using a colon, the values inside become immutable.
</p><br><span>-- Fixed size tuple of immutable integers
    tuple :: (1, 2, 3)
    tuple 0 -- returns 1

    -- Named tuple element (mutable)
    tuple_of_one := (number 69)
    int_value := 69
    tuple_of_one number is int_value -- returns true

    -- Named value with type (mutable)
    tuple_of_one : float = (number 420)
    int_value := 420
    tuple_of_one number is int_value -- returns false
</span><br><h2>Dynamic Collections (Arrays)
</h2><p>When creating a variable collection rather than a constant collection, it becomes a dynamic collection.
</p><br><p>Dynamic collections can only contain one data type.
</p><span>array := (3, 4, 5)
    array push(9)
    array 3 -- returns 9
</span><br><br><p>Specifying the type of your collection.
</p><br><span>-- Empty array of integers
    empty_array : (int)

    empty_array push(3)
    empty_array 0 -- returns 3

    strings : (string) = ("hello", "world")
</span><br><br><p>Collections can also have named values or keys. These values can now be defined as mutable or immutable.
</p><br><span>values :: (
        default_number :: 0,
        "cool number" :: 6,
        7,
        8
    )
</span><br>
<script type="module">const vnavbar = `<nav style="background-color:rgba(100, 220, 0, 0.06);" class="bs-nav-1 "  ><ul><li><a href="../" style="" class="" >&#127793;</a></li></ul></nav>`; function uInnerHTML(id,update){
                const es = document.getElementsByClassName(id);
                if (Array.isArray(update)){update = update.join(' ')}
                for (let i = 0;i<es.length;i++) {
                  es[i].innerHTML=update
                }
            }</script>
</body>
</html>