#title "Functions"
#date "2024-2-5"
---

# Functions
Their structure is: prototype containing the args for the function, the return type, then the body of the function.

A return type is required for any functions returning a value.

You specify arguments by using the prototype syntax to create a prototype literal.

Arrows are the symbol for returns within the function scope.

When functions return mutliple values, they are returned as a choice. This choice can always contain an error as a possible choice.

`
    -- Multiple return values
    multipleReturns : {} -> ( -> {1, 2, 3} )

    a = multipleReturns{}

    a.0 -- 1

`
    concatString : {a string, b string} -> string ( a + b )

    myself = concatString{
        a "I am ",
        b "really cool"
    }

    -- Using an exsisting prototype to define the args
    NormalizeVectors : Vec -> Vec (
        -> { 
            x = Vec.x / Vec.length, 
            y = Vec.y / Vec.length 
        }
    )

    -- No return value or args
    inlineSideEffect : {} -> ( state = "beans" )

    -- With default args
    addNumbers : {a = 1, b = 1} -> ( -> a + b )

    -- named args access
    result = addNumbers{a 3, b 16}

    -- Multiple return values
    multipleReturns : {} -> ( 1, 2, 3 )

    a, b, c = multipleReturns{}

    -- Anonymous functions
    {arg int} -> ( arg + 1 )
    
    {arg int} -> ( arg + 1 )

    {} -> ( "Hello, World!" )
`

# Methods
Method chaining is a core part of how data can be transformed in Beanstalk. 
The standard library imports methods that will extend certain data types.

You can't directly add methods to structs. 
Methods are instead created similarly to functions but will impliment themselves on the specified types.

Create a new method by using the Self keyword as the name of an argument. 
To impliment the method on one or more types, specify them as types of the Self argument.

`
    increment : {self int or float} -> ( self += 1 )

    number = 0
    number.incrementInt{} -- 1

    randomizeAge : {self: person} -> ( 
        self.age = int.rng(min 0, max 100) 
    )
`

# Explicit Function Overloading
Function overloading is explicit in Beanstalk, all functions must have unique names. 
But you can still have function overloading by grouping functions together. 
This is to maintain type safety and code clarity.

By creating a new variable and setting it equal to a list of functions using the plus operator. 
You can create an overloaded function that will automatically call the correct function depending on the arguments passed into it.

`
    toString : intToString + floatToString + decimalToString

    -- Can wrap in brackets for multi-line
    toString : (
        intToString +
        floatToString +
        decimalToString
    )
`