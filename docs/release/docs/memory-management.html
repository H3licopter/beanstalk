<!DOCTYPE html><html lang="en"><head>
<meta charset="UTF-8">
<meta name="viewport"content="width=device-width, initial-scale=1">
<title> | Website Title</title>
<meta name="description"content="Website Description"/>
<meta property="og:title"content=""/>
<meta property="og:description"content=""/>
<meta property="og:image"content="localhost:6969/"/>
<meta property="og:image:alt"content=""/>
<meta property="og:locale"content="en_US"/>
<meta property="og:type"content="website"/>
<meta property="og:url"content="localhost:6969/"/>
<meta name="twitter:card"content=""/>
<meta name="color-scheme" content="light dark" />
<link rel="canonical"href="">
<link rel="icon"href="../images/favicons/favicon.ico">
<!-- <link rel="icon"href="images/favicons/favicon.svg"type="image/svg+xml"> -->
<link rel="apple-touch-icon"href="../images/favicons/apple-touch-icon.png">
<link rel="manifest"href="../images/favicons/site.webmanifest">
<link rel="stylesheet" href="../css/pico.min.css" />
<style>.bs-0 > * {color:inherit;}.bs-nav-1 {
                border-bottom-color: grey;
                border-bottom-style: solid;
                border-bottom-width: 1px;
                padding: 0rem 2rem 0rem 2rem;
            }.bs-title-1 {
                font-size: 3rem;
                font-weight: bold;
                letter-spacing: 0.3rem;
                word-spacing: 0.4rem;
                margin: 1.3rem 0 1.2rem 0;
                line-height: 3.5rem;
            }.bs-0 > * {color:inherit;}</style></head><body><span class="Navbar"></span><header class="container"><div style="display:flex;align-items:center;flex-direction:column;text-align:center;"  class="" ><b class="bs-title-1 " style=""  >MEMORY MANAGEMENT</b></div></header><main class="container"><span style="color:hsla(0,90%,55%,1);"  class=" bs-0" ><span>Memory management scheme still in testing / design phase</span></span><h1>How Beanstalk handles memory
</h1><p>Beanstalk will analyze where variables are used and passed around to determine whether they are copied, moved or passed by reference.
</p><span>This will be a bit like Rust, but less explicit and easier to understand. 
</span><p>The cost of this is more work for the compiler, and a higher chance of less optimal code being generated.
</p><p>The intention is for the language to <strong>not&nbsp;</strong><span>have a garbage collector.
</span></p><p>Failing this plan, either a model similar to <a href="https://verdagon.dev/blog/linear-types-borrowing" style="" class="" >Vale's Linear Types and Generational References</a>&nbsp;<span>will be used.
</span></p><p>Or just a GC with first class support for memory arenas if none of these ideas work out.
</p><h2>Copying
</h2><p>To copy a variable, you can use the copy keyword. This will create a new variable with the same value as the original.
</p><pre><code>
    testing_memory () -> () :
        Coords : {
            x = 5
            y = 3
        }

        -- VARIABLE BRANCHING
        -- Coords is now branched into two possible places
        -- The compiler will collapse the branch depending on the use of either variable
        Coords2 = Coords

        -- A mutable reference to the original Coords is given to change_var
        change_var(Coords)

        -- Compiler now has to determine how to handle the double reference
        change_2_vars(Coords, Coords2)

        -- Branches are collapsed to one variable and ownership is passed to change_var
        change_var(Coords2)
    end

    -- References
    testing_memory_2 () -> () :
        Coords : {
            x = 5,
            y = 3,
        }

        coord_collection {Coords} = {
            Coords {x = 1, y = 3}, 
            Coords {x = 2, y = 4},
            Coords {x = 3, y = 5},
        }

        -- mutable reference given to function
        change_var(var1)

        -- Giving var1 to var2
        var2 = var1

        -- var1 ownership is given to function
        change_var(var1)
    end


    -- References
    testing_memory_3 : () -> () :
        var1 = {
            x = 5
            y = 3
        }

        -- Mutable Reference to var given to function
        change_var(~var1)

        -- Ownership given back to var1

        -- Giving var1 to var2 and var3
        var2 = ~var1
        var3 = ~var1

        -- Error, var2 was given to var3
        var2 = {4, 5}

        -- 
        change_var(~var1)
    end

    change_var (~var : float) -> () :
        var x = 3
    end

    change_var_again (~var : float) -> () :
        change_var(var)
    end
</code></pre></main>
<script type="module">  const bs_Navbar = `<nav style="background-color:rgba(100, 220, 50, 0.03);" class="bs-nav-1 "  ><ul><li><a href="../" style="color:hsla(0,0%,100%,1);padding:0rem;" class=" bs-0" ><img src="../images/default.png" style="width:10%;" class=""  /></a>&nbsp;</li></ul></nav>`;const bs_Footer = `<footer class="container"><div style="display:flex;align-items:center;flex-direction:column;text-align:center;padding:2rem 0rem 0rem 0rem ;"  class="" ><h3>&#127793;
</h3></div></footer>`;
  WebAssembly.instantiateStreaming(fetch("./memory-management.wasm")).then((obj)=>{
    let wsx = obj.instance.exports;wsx.set_wasm_globals();function uInnerHTML(id,update){
                const es = document.getElementsByClassName(id);
                if (Array.isArray(update)){update = update.join(' ')}
                for (let i = 0;i<es.length;i++) {
                  es[i].innerHTML=update
                }
            }uInnerHTML("Navbar", bs_Navbar);
  ;});</script>
</body>
</html>