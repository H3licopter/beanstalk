#title "Functions"
#date "2024-2-5"
---

# Functions
Functions are created using double colons ::

Their structure is: optional return type, prototype containing the args for the function, then the body of the function.

A return type is required for any functions returning a value.

You specify arguments by using the prototype syntax to create a prototype literal.

Arrows are the symbol for returns within the function scope.

Multiple expressions (or values) can be chained together at the end of the function with commas so it can return multiple values. 
You must assign the same or less variables to the return values of a function, any additional values the function returns that are not assigned can be ignored.

`
    concatString :: {a string, b string} -> string ( a + b )

    myself = concatString(
        a "I am ",
        b "really cool"
    )

    -- Using an exsisting prototype to define the args
    NormalizeVectors :: Vec -> Vec (
        -> { 
            x = Vec.x / Vec.length, 
            y = Vec.y / Vec.length 
        }
    )

    -- No return value or args
    inlineSideEffect :: state = "beans"

    -- With default args and implicit return
    addNumbers :: {a = 1, b = 1} -> a + b

    -- named args access
    result = addNumbers(a 3, b 16)

    -- Multiple return values
    multipleReturns :: -> 1, 2, 3

    a, b, c = multipleReturns()

    -- Anonymous functions
    int {arg int} :: (arg + 1)
    
    {arg int} :: arg + 1

    {} -> "Hello, World!"
`

# Methods
Method chaining is a core part of how data can be transformed in Beanstalk. 
The standard library imports methods that will extend certain data types.

You can't directly add methods to structs. 
Methods are instead created similarly to functions but will impliment themselves on the specified types.

Create a new method by using the Self keyword as the name of an argument. 
To impliment the method on one or more types, specify them as types of the Self argument.

`
    increment :: {self: int or float} ( -> self += 1 )

    number := 0
    number.incrementInt() -- 1

    randomizeAge : (self: person) : self.age = int.rng(0 as min, 100 as max)
`

# Explicit Function Overloading
Function overloading is explicit in Beanstalk, all functions must have unique names. 
But you can still have function overloading by grouping functions together. 
This is to maintain type safety and code clarity.

By creating a new variable and setting it equal to a list of functions using the plus operator. 
You can create an overloaded function that will automatically call the correct function depending on the arguments passed into it.

`
    toString :: intToString | floatToString | decimalToString

    -- Can wrap in brackets for multi-line
    toString :: (
        intToString |
        floatToString | 
        decimalToString
    )
`