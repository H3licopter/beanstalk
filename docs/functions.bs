#title "Functions"
#date "2024-4-14"
---

# Functions
Their structure is: 
1. the function name (can be omited for anonymous functions)
2. An equals for public and colon for private function (If not anonymous)
3. An optional tuple of arguments.
4. An arrow symbol followed by a return type. This must always be specified, even if the function returns nothing. To specify no return type, use an empty tuple `()`.
6. the the body of the function

Functions in Beanstalk look almost like they are whitespace significant, but this ain't Python. The scope of the function is opened immediately after the specified return type at the top of the function, and closed after the final return value. 

This means you can indent and use whitespace however you want, but still avoid the messiness of having many nested brackets.

A return statement must always be present at the end of a function to determine the end of its scope. You can have an empty return statement if the function itself does not return a value.

If the function can only return an error, you can use a '?' as the specified return type.  

`
    -- Multiple return values (private function)
    multipleReturns : -> int, int, int
        return 1, 2, 3

    -- When assigning mutliple values to a single variable, the variable becomes a tuple
    a = multipleReturns

    a.0 is 1 -- true
`
`
    concatString : (a string, b string) -> string
        return a + b

    myself = concatString(
        a "I am ",
        b "really cool"
    )

    -- Using an exsisting collection Type as an argument
    -- Public function
    NormalizeVectors = Vec -> Vec
        return { 
            x = Vec.x / Vec.length, 
            y = Vec.y / Vec.length 
        }

    NormalizeVectors {
        x 3, y 4
    }

    -- inlined function with no return value or args
    inlineSideEffect : -> () state = "beans"

    -- With default args
    addNumbers : (a = 1, b = 1) -> ()
        return a + b

    -- named args access
    result = addNumbers(a 3, b 16)

    sayThing : phrase string -> string
        return "{phrase}"

    -- returns a tuple
    multipleReturns : -> (int, int, int)
        return 1, 2, 3

    a, b, c = multipleReturns

    -- Anonymous functions
    (arg int) -> () arg + 1

    -> string return "Hello, World!"
`

# Methods
Method chaining is a core part of how data can be transformed in Beanstalk. 
The standard library imports methods that will extend certain data types.

Methods are instead created similarly to functions but will impliment themselves on the specified types.

Create a new method by using the Self keyword as the name of an argument. 
To impliment the method on one or more types, specify them as types of the Self argument.

`
    increment : (self int or float) -> () ( self += 1 )

    number = 0
    number.incrementInt 
    io number -- 1

    randomizeAge : self Person -> () ( 
        self.age = int.rng(min 0, max 100) 
    )
`

# Generics
